# 智能对象`SmartObject`
一个类

# 智能指针`SmartPointer`

可以指向任何由[智能对象](#智能对象smartobject)类的实例的智能指针。
它不同于标准库中的`std::unique_ptr`和`std::shared_ptr`，下面我们来看看它们的区别：

## `std::shared_ptr`
存储在`std::shared_ptr`中的数据的生命周期是由引用计数来控制的，当引用计数为0时，数据才会被销毁。

## `std::unique_ptr`
存储在`std::unique_ptr`中的数据的生命周期由指针本身来控制，当指针被销毁时，数据也会被销毁。
有点像`Rust`中的**所有权**规则。

## `SmartPointer`
`SmartPointer`本身不存储被指向的数据，如同`原始指针`那般自由。只不过`SmartPointer`会提供`isNull`接口供程序员判断该指针所指向的数据是否已失效（**包括**`野指针`）。  
这是`原始指针`做不到的地方，它无法判断自己是否为`野指针`。

# 线程安全
TODO 待提供示例代码...

# 实现思路
`原始指针`最大的痛点在于：
>`原始指针`无法判断自己是否为`野指针`。

而造成`野指针`的原因只有一个：
>指针所指向的数据已被释放，但指针本身并不知情。

因此我们可以在数据的`析构函数`上做手脚，在自己被销毁时**通知**所有指向它的指针。  

熟悉`Qt`的开发者们就知道这种功能只需要一个`信号`就可以解决。

## 性能
要实现保障了功能的最小性能开销，就得手动实现一个简单的`信号槽`功能，也许都称不上`信号槽`，只能算一些简单的`回调`功能。  
但为了保证线程安全，还是选择了现成的[sigslot](https://github.com/palacaze/sigslot)信号槽库。

## 线程安全
由于`sigslot`提供的功能是线程安全的，因此只需要保证`SmartPointer`中修改原始指针的代码是线程安全的即可。  

只需用一个`互斥锁`保护`原始指针`即可。
